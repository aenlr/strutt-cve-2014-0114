<!--
Simplified version of: https://github.com/julianvilas/rooted2k15

Which in turn is a customized version for the PoC posted by "neobyte"
at http://sec.baidu.com/index.php?research/detail/id/18 (no longer available).
-->
<%@ page language="java" import="java.lang.reflect.*, com.github.anob3it.*" %>
<%@ page import="java.beans.Introspector" %>
<%@ page import="java.beans.BeanInfo" %>
<%@ page import="java.beans.PropertyDescriptor" %>
<%@ page import="org.apache.commons.beanutils.BeanUtils" %>

<%!
    /* Find all the "set" methods that accept exactly one parameter (String,
     ** boolean or int) in the given Object, or in Objects that can be reached via
     ** "get" methods (without parameters) in a recursive way
     **
     ** Params:
     ** - Object instance : Object to process
     ** - javax.servlet.jsp.JspWriter out : Where the results will be printed
     ** - java.util.Set<Object> objects : Set of previously processed Objects
     ** - String poc : Chain of previously called getters to reach current object
     ** - int level : Current level of recursion
     */
    private void processClass(
            Object instance,
            javax.servlet.jsp.JspWriter out,
            java.util.Set<Object> objects,
            String poc,
            int level) {

        try {

            if (++level > 15 || objects.contains(instance)) {
                return;
            }

            Class<?> c = instance.getClass();
            if (c == Class.class) {
                if (objects.contains(c)) {
                    return;
                }
                objects.add(c);
            }
            objects.add(instance);

            BeanInfo info = Introspector.getBeanInfo(c);
            for (PropertyDescriptor p : info.getPropertyDescriptors()) {
                Method setter = p.getWriteMethod();
                if (setter != null) {
                    Class<?> type = p.getPropertyType();
                    if (type == String.class || type == boolean.class || type == int.class || type == Integer.class || type == long.class || type == Long.class) {
                        out.println(poc + "." + p.getName() + "<br>");
                        out.flush();
                    }
                }
            }

            /* Call recursively the current function against (not yet processed)
             ** Objects that can be reached using public get methods of the current
             ** Object (without parameters)
             */
            for (PropertyDescriptor p : info.getPropertyDescriptors()) {
                Method getter = p.getReadMethod();
                if (getter != null) {
                    // getter.setAccessible(true);
                    Object o = getter.invoke(instance);
                    if (o != null) {
                        /*
                        out.println('>' + poc + "." + p.getName() + "<br>");
                        out.flush();
                         */
                        processClass(o, out, objects, poc + "." + p.getName(), level);
                    }
                }
            }

        } catch (Exception x) {
            x.printStackTrace();
        }
    }

    /* Return the Object that results of resolving the chain of getters described
     ** by the "poc" parameter
     */
    private Object applyGetChain(
            Object initarget,
            String poc) throws Exception {

        if (poc == null || poc.isEmpty()) {
            return initarget;
        } else {
            return BeanUtils.getProperty(initarget, poc);
        }
    }

%>

<%
    /*
     ** MAIN METHOD
     */
    java.util.Set<Object> set = new java.util.HashSet<>();
    String poc = request.getParameter("poc");

    // Get the target Object as described by poc
    Object target = new LoginForm();
    if (poc != null && !poc.isEmpty()) {
        target = BeanUtils.getProperty(target, poc);
    }

    processClass(target, out, set, poc != null ? poc : "", 0);
%>
